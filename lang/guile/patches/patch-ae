--- libguile/gc_os_dep.c.orig	Fri Jun 26 13:21:44 2009
+++ libguile/gc_os_dep.c	Sat Apr 17 13:35:43 2010
--- libguile/gc_os_dep.c.orig	2009-06-26 20:21:44.000000000 +0000
+++ libguile/gc_os_dep.c
@@ -132,7 +132,7 @@ typedef int GC_bool;
 #    define NETBSD
 #    define mach_type_known
 # endif
-# if defined(__NetBSD__) && defined(__sparc__)
+# if defined(__NetBSD__) && (defined(__sparc__) || defined(__sparc_v9__))
 #    define SPARC
 #    define NETBSD
 #    define mach_type_known
@@ -304,6 +304,11 @@ typedef int GC_bool;
 #   define NETBSD
 #   define mach_type_known
 # endif
+# if defined(__NetBSD__) && defined(__x86_64__)
+#   define X86_64
+#   define NETBSD
+#   define mach_type_known
+# endif
 # if defined(bsdi) && defined(i386)
 #    define I386
 #    define BSDI
@@ -444,12 +449,12 @@ scm_get_stack_base ()
 /*
  * For each architecture and OS, the following need to be defined:
  *
- * CPP_WORD_SZ is a simple integer constant representing the word size.
+ * CPP_WORDSZ is a simple integer constant representing the word size.
  * in bits.  We assume byte addressibility, where a byte has 8 bits.
- * We also assume CPP_WORD_SZ is either 32 or 64.
+ * We also assume CPP_WORDSZ is either 32 or 64.
  * (We care about the length of pointers, not hardware
  * bus widths.  Thus a 64 bit processor with a C compiler that uses
- * 32 bit pointers should use CPP_WORD_SZ of 32, not 64. Default is 32.)
+ * 32 bit pointers should use CPP_WORDSZ of 32, not 64. Default is 32.)
  *
  * MACH_TYPE is a string representation of the machine type.
  * OS_TYPE is analogous for the OS.
@@ -706,13 +711,17 @@ scm_get_stack_base ()
     extern int etext;
 #   ifdef SUNOS5
 #	define OS_TYPE "SUNOS5"
-	extern int _etext;
-	extern int _end;
-	extern char * GC_SysVGetDataStart();
-#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &_etext)
-#	define DATAEND (&_end)
-#	ifndef USE_MMAP
+	extern int _etext[];
+	extern int _end[];
+	extern ptr_t GC_SysVGetDataStart();
+#       define DATASTART GC_SysVGetDataStart(0x10000, _etext)
+#	define DATAEND (_end)
+#	if !defined(USE_MMAP) && defined(REDIRECT_MALLOC)
 #	    define USE_MMAP
+	    /* Otherwise we now use calloc.  Mmap may result in the	*/
+	    /* heap interleaved with thread stacks, which can result in	*/
+	    /* excessive blacklisting.  Sbrk is unusable since it	*/
+	    /* doesn't interact correctly with the system malloc.	*/
 #	endif
 #       ifdef USE_MMAP
 #         define HEAP_START (ptr_t)0x40000000
@@ -720,10 +729,18 @@ scm_get_stack_base ()
 #	  define HEAP_START DATAEND
 #       endif
 #	define PROC_VDB
-/*	HEURISTIC1 reportedly no longer works under 2.7.  Thus we	*/
-/* 	switched to HEURISTIC2, eventhough it creates some debugging	*/
-/*	issues.								*/
-#	define HEURISTIC2
+/*	HEURISTIC1 reportedly no longer works under 2.7.  		*/
+/*  	HEURISTIC2 probably works, but this appears to be preferable.	*/
+/*	Apparently USRSTACK is defined to be USERLIMIT, but in some	*/
+/* 	installations that's undefined.  We work around this with a	*/
+/*	gross hack:							*/
+#       include <sys/vmparam.h>
+#	ifdef USERLIMIT
+	  /* This should work everywhere, but doesn't.	*/
+#	  define STACKBOTTOM USRSTACK
+#       else
+#	  define HEURISTIC2
+#       endif
 #	include <unistd.h>
 #       define GETPAGESIZE()  sysconf(_SC_PAGESIZE)
 		/* getpagesize() appeared to be missing from at least one */
@@ -797,15 +814,29 @@ scm_get_stack_base ()
 #   endif
 #   ifdef SUNOS5
 #	define OS_TYPE "SUNOS5"
-  	extern int etext, _start;
-  	extern char * GC_SysVGetDataStart();
-#       define DATASTART GC_SysVGetDataStart(0x1000, &etext)
-#	define STACKBOTTOM ((ptr_t)(&_start))
-/** At least in Solaris 2.5, PROC_VDB gives wrong values for dirty bits. */
-/*#	define PROC_VDB*/
+        extern int _etext[], _end[];
+  	extern ptr_t GC_SysVGetDataStart();
+#       define DATASTART GC_SysVGetDataStart(0x1000, _etext)
+#	define DATAEND (_end)
+/*	# define STACKBOTTOM ((ptr_t)(_start)) worked through 2.7,  	*/
+/*      but reportedly breaks under 2.8.  It appears that the stack	*/
+/* 	base is a property of the executable, so this should not break	*/
+/* 	old executables.						*/
+/*  	HEURISTIC2 probably works, but this appears to be preferable.	*/
+#       include <sys/vm.h>
+#	define STACKBOTTOM USRSTACK
+/* At least in Solaris 2.5, PROC_VDB gives wrong values for dirty bits. */
+/* It appears to be fixed in 2.8 and 2.9.				*/
+#	ifdef SOLARIS25_PROC_VDB_BUG_FIXED
+#	  define PROC_VDB
+#	endif
 #	define DYNAMIC_LOADING
-#	ifndef USE_MMAP
+#	if !defined(USE_MMAP) && defined(REDIRECT_MALLOC)
 #	    define USE_MMAP
+	    /* Otherwise we now use calloc.  Mmap may result in the	*/
+	    /* heap interleaved with thread stacks, which can result in	*/
+	    /* excessive blacklisting.  Sbrk is unusable since it	*/
+	    /* doesn't interact correctly with the system malloc.	*/
 #	endif
 #       ifdef USE_MMAP
 #         define HEAP_START (ptr_t)0x40000000
@@ -994,6 +1025,21 @@ scm_get_stack_base ()
 #    endif
 # endif
 
+# ifdef X86_64
+#   define MACH_TYPE "X86_64"
+#   define ALIGNMENT 8
+#   define ALIGN_DOUBLE
+#   define CPP_WORDSZ 64
+#   ifdef NETBSD
+#	define OS_TYPE "NETBSD"
+#   endif
+#   if defined(NETBSD)
+#	define HEURISTIC2
+	extern char etext;
+#	define DATASTART ((ptr_t)(&etext))
+#   endif
+#   endif
+
 # ifdef NS32K
 #   define MACH_TYPE "NS32K"
 #   define ALIGNMENT 4
