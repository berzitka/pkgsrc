$NetBSD: patch-br,v 1.8 2011/10/30 05:07:15 manu Exp $

Use linkat(2) if available so that we can make a hardlink to symlink 
itself, instead of symlink destination, like link(2) does. This is
required to support moving symlinks on distributed volumes, as
glusterfsd really wants to hardlink the symlink and not its target. 

If linkat(2) is inavailable, then moving a symlink on distributed
volumes fails.

Also pull upstreampatch that fix inode generation so that values 
are reliable

--- xlators/storage/posix/src/posix.c.orig	2011-08-23 14:31:42.000000000 +0200
+++ xlators/storage/posix/src/posix.c	2011-10-28 14:59:13.000000000 +0200
@@ -36,8 +36,12 @@
 #ifndef GF_BSD_HOST_OS
 #include <alloca.h>
 #endif /* GF_BSD_HOST_OS */
 
+#ifdef HAVE_LINKAT
+#include <fcntl.h>
+#endif /* HAVE_LINKAT */
+
 #include "glusterfs.h"
 #include "md5.h"
 #include "checksum.h"
 #include "dict.h"
@@ -244,8 +248,23 @@
 
         return ret;
 }
 
+void
+posix_fill_ino_from_gfid (xlator_t *this, struct iatt *buf)
+{
+        uint64_t temp_ino = 0;
+        int j = 0;
+        int i = 0;
+
+        /* consider least significant 8 bytes of value out of gfid */
+        for (i = 15; i > (15 - 8); i--) {
+                temp_ino += (uint64_t)(buf->ia_gfid[i]) << j;
+                j += 8;
+        }
+
+        buf->ia_ino = temp_ino;
+}
 
 int
 posix_lstat_with_gfid (xlator_t *this, const char *path, struct iatt *stbuf_p)
 {
@@ -265,8 +284,10 @@
         ret = posix_fill_gfid_path (this, path, &stbuf);
         if (ret)
                 gf_log_callingfn (this->name, GF_LOG_DEBUG, "failed to get gfid");
 
+        posix_fill_ino_from_gfid (this, &stbuf);
+
         if (stbuf_p)
                 *stbuf_p = stbuf;
 out:
         return ret;
@@ -292,8 +313,10 @@
         ret = posix_fill_gfid_fd (this, fd, &stbuf);
         if (ret)
                 gf_log_callingfn (this->name, GF_LOG_DEBUG, "failed to get gfid");
 
+        posix_fill_ino_from_gfid (this, &stbuf);
+
         if (stbuf_p)
                 *stbuf_p = stbuf;
 
 out:
@@ -1232,8 +1255,13 @@
                         loc->path, strerror (op_errno));
                 goto out;
         }
 
+#ifdef __NetBSD__
+	if (S_ISFIFO(mode))
+		op_ret = mkfifo (real_path, mode);
+	else
+#endif /* __NetBSD__ */
         op_ret = mknod (real_path, mode, dev);
 
         if (op_ret == -1) {
                 op_errno = errno;
@@ -2125,9 +2153,20 @@
                         newparentpath, strerror (op_errno));
                 goto out;
         }
 
+#ifdef HAVE_LINKAT
+	/*
+	 * On most systems (Linux being the notable exception), link(2)
+	 * first resolves symlinks. If the target is a directory or
+	 * is nonexistent, it will fail. linkat(2) operates on the 
+	 * symlink instead of its target when the AT_SYMLINK_FOLLOW
+	 * flag is not supplied.
+	 */
+        op_ret = linkat (AT_FDCWD, real_oldpath, AT_FDCWD, real_newpath, 0);
+#else
         op_ret = link (real_oldpath, real_newpath);
+#endif
         if (op_ret == -1) {
                 op_errno = errno;
                 gf_log (this->name, GF_LOG_ERROR,
                         "link %s to %s failed: %s",
@@ -4376,13 +4415,15 @@
 
         /* pick ENOENT to indicate EOF */
         op_errno = errno;
 
-        if (whichop == GF_FOP_READDIRP) {
-                list_for_each_entry (tmp_entry, &entries.list, list) {
-                        strcpy (entry_path + real_path_len + 1,
-                                tmp_entry->d_name);
-                        posix_lstat_with_gfid (this, entry_path, &stbuf);
+        list_for_each_entry (tmp_entry, &entries.list, list) {
+                strcpy (entry_path + real_path_len + 1,
+                        tmp_entry->d_name);
+                posix_lstat_with_gfid (this, entry_path, &stbuf);
+                tmp_entry->d_ino = stbuf.ia_ino;
+
+                if (whichop == GF_FOP_READDIRP) {
                         tmp_entry->d_stat = stbuf;
                 }
         }
 
