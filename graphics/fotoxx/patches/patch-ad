$NetBSD: patch-ad,v 1.1 2010/08/24 18:58:03 bad Exp $

--- fotoxx-10.8.4.cc.orig	2010-08-18 11:23:51.000000000 +0000
+++ fotoxx-10.8.4.cc	2010-08-22 23:59:53.000000000 +0000
@@ -145,7 +145,7 @@
 int         gridy1 = 0, gridy2 = 0, gridny = 0;                            //  Y gridlines
 int         Fslideshow = 0;                                                //  slide show mode is active
 int         SS_interval = 3;                                               //  slide show interval
-int         SS_timer = 0;                                                  //  slide show timer
+double         SS_timer = 0;                                                  //  slide show timer
 int         SBupdate = 0;                                                  //  request to update status bar
 int         SB_goal = 0, SB_done = 0;                                      //  status bar progress tracking
 char        SB_text[100];                                                  //  optional status bar text
@@ -985,25 +985,25 @@
    else Mscale = Fzoom;                                                    //  scale to Fzoom level
 
    if (Mscale > pscale) {                                                  //  zoom increased
-      Iorgx += iww * 0.5 * (1.0 - pscale / Mscale);                        //  keep current image center
-      Iorgy += ihh * 0.5 * (1.0 - pscale / Mscale);
+      Iorgx += (int)(iww * 0.5 * (1.0 - pscale / Mscale));                        //  keep current image center
+      Iorgy += (int)(ihh * 0.5 * (1.0 - pscale / Mscale));
    }
    pscale = Mscale;
    
-   iww = Dww / Mscale;                                                     //  image space fitting in window
+   iww = (int)(Dww / Mscale);                                                     //  image space fitting in window
    if (iww > Iww) iww = Iww;
-   ihh = Dhh / Mscale;
+   ihh = (int)(Dhh / Mscale);
    if (ihh > Ihh) ihh = Ihh;
 
    if (zoomx || zoomy) {                                                   //  req. zoom center
-      Iorgx = zoomx - 0.5 * iww;                                           //  corresp. image origin
-      Iorgy = zoomy - 0.5 * ihh;
+      Iorgx = (int)(zoomx - 0.5 * iww);                                           //  corresp. image origin
+      Iorgy = (int)(zoomy - 0.5 * ihh);
       zoomx = zoomy = 0;
    }
 
    if ((Mxdrag || Mydrag) && ! Mcapture) {                                 //  scroll via mouse drag
-      incrx = (Mxdrag - Mxdown) * 1.3 * Iww / iww;                         //  scale
-      incry = (Mydrag - Mydown) * 1.3 * Ihh / ihh;
+      incrx = (int)((Mxdrag - Mxdown) * 1.3 * Iww / iww);                         //  scale
+      incry = (int)((Mydrag - Mydown) * 1.3 * Ihh / ihh);
       if (pincrx > 0 && incrx < 0) incrx = 0;                              //  stop bounce at extremes
       if (pincrx < 0 && incrx > 0) incrx = 0;
       pincrx = incrx;
@@ -1019,13 +1019,13 @@
 
    if (iww == Iww) {                                                       //  scaled image <= window width
       Iorgx = 0;                                                           //  center image in window
-      Dorgx = 0.5 * (Dww - Iww * Mscale);
+      Dorgx = (int)(0.5 * (Dww - Iww * Mscale));
    }
    else Dorgx = 0;                                                         //  image > window, use entire window
 
    if (ihh == Ihh) {                                                       //  same for image height
       Iorgy = 0;
-      Dorgy = 0.5 * (Dhh - Ihh * Mscale);
+      Dorgy = (int)(0.5 * (Dhh - Ihh * Mscale));
    }
    else Dorgy = 0;
    
@@ -1041,8 +1041,8 @@
    }
    else pxmtemp2 = PXM_copy_area(Fpxm8,Iorgx,Iorgy,iww,ihh);               //  no edit, copy PXM-8
 
-   dww = iww * Mscale;                                                     //  scale to window
-   dhh = ihh * Mscale;
+   dww = (int)(iww * Mscale);                                                     //  scale to window
+   dhh = (int)(ihh * Mscale);
    PXM_free(Dpxm8);
    Dpxm8 = PXM_rescale(pxmtemp2,dww,dhh);
    PXM_free(pxmtemp2);
@@ -1120,7 +1120,7 @@
 
    if (SB_goal)                                                            //  progress monitor       v.9.6
    {
-      percent_done = 100 * (1.0 * SB_done / SB_goal);
+      percent_done = (int)(100 * (1.0 * SB_done / SB_goal));
       snprintf(text2,99,"  done: %d%c",percent_done,'%');
       strcat(text1,text2);
    }
@@ -1477,7 +1477,7 @@
    x2 = Mscale * (ix2-Iorgx);
    y2 = Mscale * (iy2-Iorgy);
    
-   if (abs(y2 - y1) > abs(x2 - x1)) {
+   if (fabs(y2 - y1) > fabs(x2 - x1)) {
       slope = 1.0 * (x2 - x1) / (y2 - y1);
       if (y2 > y1) {
          for (pym = y1; pym <= y2; pym++) {
@@ -1548,7 +1548,7 @@
    x2 = Mscale * (ix2-Iorgx);
    y2 = Mscale * (iy2-Iorgy);
    
-   if (abs(y2 - y1) > abs(x2 - x1)) {
+   if (fabs(y2 - y1) > fabs(x2 - x1)) {
       slope = 1.0 * (x2 - x1) / (y2 - y1);
       if (y2 > y1) {
          for (pym = y1; pym <= y2; pym++) {
@@ -1865,7 +1865,7 @@
             if (xval < apx[spc][0]) continue;
             if (xval > apx[spc][nap[spc]-1]) continue;
             yval = curve_yval(spc,xval);
-            px = ww * yval + 0.49;                                         //  almost round - erratic FP in Intel CPUs
+            px = (int)(ww * yval + 0.49);                                         //  almost round - erratic FP in Intel CPUs
             gdk_draw_point(drawarea->window,gdkgc,px,py);                  //    causes "bumps" in a flat curve
          }
          
@@ -1873,8 +1873,8 @@
          {
             xval = apx[spc][ap];
             yval = apy[spc][ap];
-            px = ww * yval;
-            py = hh * xval;
+            px = (int)(ww * yval);
+            py = (int)(hh * xval);
             for (qx = -2; qx < 3; qx++)
             for (qy = -2; qy < 3; qy++) {
                if (px+qx < 0 || px+qx >= ww) continue;
@@ -1891,7 +1891,7 @@
             if (xval < apx[spc][0]) continue;
             if (xval > apx[spc][nap[spc]-1]) continue;
             yval = curve_yval(spc,xval);
-            py = hh - hh * yval + 0.49;                                    //  almost round - erratic FP in Intel CPUs
+            py = (int)(hh - hh * yval + 0.49);                                    //  almost round - erratic FP in Intel CPUs
             gdk_draw_point(drawarea->window,gdkgc,px,py);                  //    causes "bumps" in a flat curve
          }
          
@@ -1899,8 +1899,8 @@
          {
             xval = apx[spc][ap];
             yval = apy[spc][ap];
-            px = ww * xval;
-            py = hh - hh * yval;
+            px = (int)(ww * xval);
+            py = (int)(hh - hh * yval);
             for (qx = -2; qx < 3; qx++)
             for (qy = -2; qy < 3; qy++) {
                if (px+qx < 0 || px+qx >= ww) continue;
@@ -1926,9 +1926,9 @@
 
    spline1(nap[spc],apx[spc],apy[spc]);                                    //  compute curve fitting anchor points
 
-   kklo = 1000 * apx[spc][0] - 30;                                         //  xval range = anchor point range
+   kklo = (int)(1000 * apx[spc][0] - 30);                                         //  xval range = anchor point range
    if (kklo < 0) kklo = 0;                                                 //    + 0.03 extra below/above      v.9.5
-   kkhi = 1000 * apx[spc][nap[spc]-1] + 30;
+   kkhi = (int)(1000 * apx[spc][nap[spc]-1] + 30);
    if (kkhi > 1000) kkhi = 1000;
 
    for (kk = 0; kk < 1000; kk++)                                           //  generate all points for curve
@@ -1990,7 +1990,7 @@
    if (image_file)
       image_gallery(image_file,"paint1",0,m_gallery2);                     //  force show gallery window    v.10.6
    else {
-      char *pp = get_current_dir_name();
+      char *pp = getcwd((char *)0, 0);
       if (pp) {
          image_gallery(pp,"paint1",0,m_gallery2);
          free(pp);
@@ -3181,7 +3181,7 @@
       zdialog_free(zd);
       SS_interval = secs;                                                  //  interval between slides
       if (zstat != 1) secs = 9999;                                         //  cancel, use huge interval
-      SS_timer = get_seconds() + secs + 1;                                 //  set timer for next slide
+      SS_timer = (int)(get_seconds() + secs + 1);                                 //  set timer for next slide
       Fslideshow = 1;
    }
 
@@ -6531,7 +6531,7 @@
    int         ii, click, newseq, thresh;
    static int  drag = 0, mdx0, mdy0, mdx1, mdy1;
 
-   sa_thresh = 4.0 / Mscale + 1;                                           //  mouse pixel distance threshold
+   sa_thresh = (int)(4.0 / Mscale + 1);                                           //  mouse pixel distance threshold
    click = newseq = 0;
    
    if (LMclick || Mxdrag || Mydrag)                                        //  left mouse click or mouse drag
@@ -6665,7 +6665,7 @@
       }
    }
    
-   if (npx + npy) return sqrt(mindist) + 0.5;
+   if (npx + npy) return (int)(sqrt(mindist) + 0.5);
    return 0;
 }
 
@@ -6689,13 +6689,13 @@
       slope = 1.0 * (px2 - px1) / (py2 - py1);
       if (py2 > py1) {
          for (pym = py1; pym <= py2; pym++) {
-            pxm = round(px1 + slope * (pym - py1));
+            pxm = (int)round(px1 + slope * (pym - py1));
             sa_draw1pix(pxm,pym);
          }
       }
       else {
          for (pym = py1; pym >= py2; pym--) {
-            pxm = round(px1 + slope * (pym - py1));
+            pxm = (int)round(px1 + slope * (pym - py1));
             sa_draw1pix(pxm,pym);
          }
       }
@@ -6704,13 +6704,13 @@
       slope = 1.0 * (py2 - py1) / (px2 - px1);
       if (px2 > px1) {
          for (pxm = px1; pxm <= px2; pxm++) {
-            pym = round(py1 + slope * (pxm - px1));
+            pym = (int)round(py1 + slope * (pxm - px1));
             sa_draw1pix(pxm,pym);
          }
       }
       else {
          for (pxm = px1; pxm >= px2; pxm--) {
-            pym = round(py1 + slope * (pxm - px1));
+            pym = (int)round(py1 + slope * (pxm - px1));
             sa_draw1pix(pxm,pym);
          }
       }
@@ -6764,7 +6764,7 @@
       {                                                                    //    and perpendicular to p4 - p2
          px5 = px4 + ii * dy / dist;
          py5 = py4 - ii * dx / dist;
-         contrast = sa_get_contrast(px5,py5);
+         contrast = sa_get_contrast((int)px5,(int)py5);
          if (contrast > maxcontrast) {
             px6 = px5;                                                     //  p6 = highest contrast point in p5
             py6 = py5;
@@ -6772,13 +6772,13 @@
          }
       }
       
-      sa_draw_line(px3,py3,px6,py6);                                       //  draw p3 to p6
+      sa_draw_line((int)px3,(int)py3,(int)px6,(int)py6);                                       //  draw p3 to p6
 
       px3 = px6;                                                           //  next p3
       py3 = py6;
    }
    
-   sa_draw_line(px3,py3,px2,py2);
+   sa_draw_line((int)px3,(int)py3,px2,py2);
    return;
 }
 
@@ -6913,7 +6913,7 @@
    memset(sa_pixselc,0,cc);
 
    radius = sa_colorradius;                                                //  use radius from dialog     v.10.8
-   if (! radius) radius = 1 + 1.0 / Mscale;                                //  or small default radius
+   if (! radius) radius = (int)(1 + 1.0 / Mscale);                                //  or small default radius
    radius2 = radius * radius;
 
    sa_Nmatch = 0;                                                          //  match color count
@@ -7643,7 +7643,7 @@
 
    for (nn = 0; nn < Fww * Fhh * 2; nn++)                                  //  do random pixels    v.9.6
    {
-      ii = drandz(&seed) * Fww * Fhh;
+      ii = (int)(drandz(&seed) * Fww * Fhh);
       if (sa_pixisin[ii] < 2) continue;                                    //  ignore outside and edge pixels
       if (sa_edgedist[ii]) continue;                                       //  already calculated
       py = ii / Fww;
@@ -7710,12 +7710,12 @@
       if (epy > py1) inc = 1;
       else inc = -1;
       for (pym = py1; pym != epy; pym += inc) {
-         pxm = px1 + slope * (pym - py1);
+         pxm = (int)(px1 + slope * (pym - py1));
          ii = pym * Fww + pxm;
          if (sa_edgedist[ii]) continue;
          dx = epx - pxm;                                                   //  calculate distance to edge
          dy = epy - pym;
-         dist2 = sqrt(dx*dx + dy*dy) + 0.5;
+         dist2 = (uint)(sqrt(dx*dx + dy*dy) + 0.5);
          sa_edgedist[ii] = dist2;                                          //  save
          SB_done++;
       }
@@ -7726,12 +7726,12 @@
       if (epx > px1) inc = 1;
       else inc = -1;
       for (pxm = px1; pxm != epx; pxm += inc) {
-         pym = py1 + slope * (pxm - px1);
+         pym = (int)(py1 + slope * (pxm - px1));
          ii = pym * Fww + pxm;
          if (sa_edgedist[ii]) continue;
          dx = epx - pxm;
          dy = epy - pym;
-         dist2 = sqrt(dx*dx + dy*dy) + 0.5;
+         dist2 = (int)sqrt(dx*dx + dy*dy) + 0.5;
          sa_edgedist[ii] = dist2;
          SB_done++;
       }
@@ -7770,7 +7770,7 @@
    }
    
    kk = py1 * Fww + px1;
-   sa_edgedist[kk] = sqrt(mindist2) + 0.5;
+   sa_edgedist[kk] = (int)(sqrt(mindist2) + 0.5);
 
    SB_done++;
    return;
