$NetBSD: patch-bc,v 1.3 2010/10/01 21:32:34 spz Exp $

security fixes for http://secunia.com/advisories/41596/
taken from http://cgit.freedesktop.org/poppler

- Fix memory leak

--- poppler/Stream.cc.orig	2010-06-08 20:06:31.000000000 +0000
+++ poppler/Stream.cc
@@ -99,6 +99,10 @@ int Stream::getRawChar() {
   return EOF;
 }
 
+void Stream::getRawChars(int nChars, int *buffer) {
+  error(-1, "Internal: called getRawChars() on non-predictor stream");
+}
+
 char *Stream::getLine(char *buf, int size) {
   int i;
   int c;
@@ -571,19 +575,22 @@ GBool StreamPredictor::getNextLine() {
   }
 
   // read the raw line, apply PNG (byte) predictor
+  int *rawCharLine = new int[rowBytes - pixBytes];
+  str->getRawChars(rowBytes - pixBytes, rawCharLine);
   memset(upLeftBuf, 0, pixBytes + 1);
   for (i = pixBytes; i < rowBytes; ++i) {
     for (j = pixBytes; j > 0; --j) {
       upLeftBuf[j] = upLeftBuf[j-1];
     }
     upLeftBuf[0] = predLine[i];
-    if ((c = str->getRawChar()) == EOF) {
+    if ((c = rawCharLine[i - pixBytes]) == EOF) {
       if (i > pixBytes) {
 	// this ought to return false, but some (broken) PDF files
 	// contain truncated image data, and Adobe apparently reads the
 	// last partial line
 	break;
       }
+      delete[] rawCharLine;
       return gFalse;
     }
     switch (curPred) {
@@ -1237,16 +1244,13 @@ int LZWStream::lookChar() {
   return seqBuf[seqIndex];
 }
 
+void LZWStream::getRawChars(int nChars, int *buffer) {
+  for (int i = 0; i < nChars; ++i)
+    buffer[i] = doGetRawChar();
+}
+
 int LZWStream::getRawChar() {
-  if (eof) {
-    return EOF;
-  }
-  if (seqIndex >= seqLength) {
-    if (!processNextCode()) {
-      return EOF;
-    }
-  }
-  return seqBuf[seqIndex++];
+  return doGetRawChar();
 }
 
 void LZWStream::reset() {
@@ -4262,18 +4266,13 @@ int FlateStream::lookChar() {
   return c;
 }
 
-int FlateStream::getRawChar() {
-  int c;
+void FlateStream::getRawChars(int nChars, int *buffer) {
+  for (int i = 0; i < nChars; ++i)
+    buffer[i] = doGetRawChar();
+}
 
-  while (remain == 0) {
-    if (endOfBlock && eof)
-      return EOF;
-    readSome();
-  }
-  c = buf[index];
-  index = (index + 1) & flateMask;
-  --remain;
-  return c;
+int FlateStream::getRawChar() {
+  return doGetRawChar();
 }
 
 GooString *FlateStream::getPSFilter(int psLevel, char *indent) {
