$NetBSD: patch-ag,v 1.3 2011/02/07 22:08:42 wiz Exp $

Fix for png-1.5.

--- bitmap/bmpng.c.orig	2009-10-16 15:20:57.000000000 +0000
+++ bitmap/bmpng.c
@@ -20,23 +20,29 @@
 /*									*/
 /************************************************************************/
 
-static int bpPngiToBitmap(	const png_info *		pngi,
+static int bpPngiToBitmap(	const png_structp		png,
+				const png_info *		pngi,
 				BitmapDescription *		bd )
     {
     unsigned int	col;
+    png_colorp palette;
+    int num_palette;
+    png_uint_32 res_x, res_y;
+    int unit_type;
 
-    bd->bdPixelsWide= pngi->width;
-    bd->bdPixelsHigh= pngi->height;
+    bd->bdPixelsWide= png_get_image_width(png, pngi);
+    bd->bdPixelsHigh= png_get_image_height(png, pngi);
     bd->bdHasAlpha= 0;
 
-    switch( pngi->color_type )
+    png_get_PLTE( png, pngi, &palette, &num_palette );
+    switch( png_get_color_type( png, pngi ) )
 	{
 	case PNG_COLOR_TYPE_PALETTE:
 	    bd->bdColorEncoding= BMcoRGB8PALETTE;
-	    bd->bdColorCount= pngi->num_palette;
+	    bd->bdColorCount= num_palette;
 	    bd->bdBitsPerSample= 8;
 	    bd->bdSamplesPerPixel= 3;
-	    bd->bdBitsPerPixel= pngi->bit_depth;
+	    bd->bdBitsPerPixel= png_get_bit_depth( png, pngi );
 
 	    bd->bdRGB8Palette= (RGB8Color *)
 				malloc( bd->bdColorCount* sizeof(RGB8Color) );
@@ -46,47 +52,48 @@ static int bpPngiToBitmap(	const png_inf
 
 	    for ( col= 0; col < bd->bdColorCount; col++ )
 		{
-		bd->bdRGB8Palette[col].rgb8Red= pngi->palette[col].red;
-		bd->bdRGB8Palette[col].rgb8Green= pngi->palette[col].green;
-		bd->bdRGB8Palette[col].rgb8Blue= pngi->palette[col].blue;
+		bd->bdRGB8Palette[col].rgb8Red= palette[col].red;
+		bd->bdRGB8Palette[col].rgb8Green= palette[col].green;
+		bd->bdRGB8Palette[col].rgb8Blue= palette[col].blue;
 		bd->bdRGB8Palette[col].rgb8Alpha= 0;
 		}
 	    break;
 
 	case PNG_COLOR_TYPE_RGB:
 	    bd->bdColorEncoding= BMcoRGB;
-	    bd->bdBitsPerSample= pngi->bit_depth;
-	    bd->bdSamplesPerPixel= pngi->channels;
-	    bd->bdBitsPerPixel= pngi->pixel_depth;
+	    bd->bdBitsPerSample= png_get_bit_depth( png, pngi );
+	    bd->bdSamplesPerPixel= png_get_channels( png, pngi );
+	    bd->bdBitsPerPixel= ( png_get_rowbytes( png, pngi ) + 7 ) / png_get_image_width( png, pngi );
 	    break;
 
 	case PNG_COLOR_TYPE_GRAY:
 	    bd->bdColorEncoding= BMcoWHITEBLACK;
-	    bd->bdBitsPerSample= pngi->bit_depth;
-	    bd->bdSamplesPerPixel= pngi->channels;
-	    bd->bdBitsPerPixel= pngi->pixel_depth;
+	    bd->bdBitsPerSample= png_get_bit_depth( png, pngi );
+	    bd->bdSamplesPerPixel= png_get_channels( png, pngi );
+	    bd->bdBitsPerPixel= ( png_get_rowbytes( png, pngi ) + 7 ) / png_get_image_width( png, pngi );
 	    break;
 
 	case PNG_COLOR_TYPE_RGB_ALPHA:
 	    bd->bdHasAlpha= 1;
 	    bd->bdColorEncoding= BMcoRGB;
-	    bd->bdBitsPerSample= pngi->bit_depth;
-	    bd->bdSamplesPerPixel= pngi->channels;
-	    bd->bdBitsPerPixel= pngi->pixel_depth;
+	    bd->bdBitsPerSample= png_get_bit_depth( png, pngi );
+	    bd->bdSamplesPerPixel= png_get_channels( png, pngi );
+	    bd->bdBitsPerPixel= ( png_get_rowbytes( png, pngi ) + 7 ) / png_get_image_width( png, pngi );
 	    break;
 
 	case PNG_COLOR_TYPE_GRAY_ALPHA:
 	    bd->bdHasAlpha= 1;
-	    LDEB(pngi->color_type); return -1;
+	    LDEB(png_get_color_type( png, pngi )); return -1;
 
 	default:
-	    LDEB(pngi->color_type); return -1;
+	    LDEB(png_get_color_type( png, pngi )); return -1;
 	}
 
-    bd->bdBytesPerRow= pngi->rowbytes;
+    bd->bdBytesPerRow= png_get_rowbytes( png, pngi );
     bd->bdBufferLength= bd->bdBytesPerRow* bd->bdPixelsHigh;
 
-    switch( pngi->phys_unit_type )
+    png_get_pHYs( png, pngi, &res_x, &res_y, &unit_type);
+    switch( unit_type )
 	{
 	case PNG_RESOLUTION_UNKNOWN:
 	    bd->bdUnit= BMunPIXEL;
@@ -96,12 +103,12 @@ static int bpPngiToBitmap(	const png_inf
 
 	case PNG_RESOLUTION_METER:
 	    bd->bdUnit= BMunM;
-	    bd->bdXResolution= pngi->x_pixels_per_unit;
-	    bd->bdYResolution= pngi->y_pixels_per_unit;
+	    bd->bdXResolution= res_x;
+	    bd->bdYResolution= res_y;
 	    break;
 
 	default:
-	    LDEB(pngi->phys_unit_type);
+	    LDEB(unit_type);
 	    return -1;
 	}
 
@@ -119,11 +126,11 @@ static int bmPngReadContents(	png_info *
     unsigned char *		buffer;
 
     numberOfPasses= 1;
-    if  ( pngi->interlace_type )
+    if  ( png_get_interlace_type( png, pngi ) )
 	{ numberOfPasses= png_set_interlace_handling( png ); }
 
-    if  ( pngi->color_type == PNG_COLOR_TYPE_RGB	&&
-	  pngi->bit_depth == 16				)
+    if  ( png_get_color_type( png, pngi ) == PNG_COLOR_TYPE_RGB	&&
+	  png_get_bit_depth( png, pngi ) == 16				)
 	{
 	const unsigned short	one= 1;
 	const unsigned char *	testEndian= (const unsigned char *)&one;
@@ -236,9 +243,9 @@ int bmPngReadPng(	BitmapDescription *	bd
 
     png_read_info( pngp, pngip );
 
-    if  ( bpPngiToBitmap( pngip, bd ) )
+    if  ( bpPngiToBitmap( pngp, pngip, bd ) )
 	{
-	LLLDEB(pngip->color_type,bd->bdColorCount,bd->bdRGB8Palette); 
+	LLLDEB(png_get_color_type( pngp, pngip ),bd->bdColorCount,bd->bdRGB8Palette); 
 	png_destroy_read_struct( &pngp, &pngip, (png_infop *)0 );
 	return -1;
 	}
@@ -284,94 +291,91 @@ static int bpPngiFromBitmap(	png_structp
 				png_info *			pngi,
 				const BitmapDescription *       bd )
     {
-    png_info_init( pngi );
-    pngi->width= bd->bdPixelsWide;
-    pngi->height= bd->bdPixelsHigh;
+    int bit_depth, color_type, interlace_type;
 
     switch( bd->bdUnit )
 	{
 	case BMunM:
-	    pngi->phys_unit_type= PNG_RESOLUTION_METER;
-	    pngi->x_pixels_per_unit= bd->bdXResolution;
-	    pngi->y_pixels_per_unit= bd->bdYResolution;
-	    pngi->valid |= PNG_INFO_pHYs;
+	    png_set_pHYs(png, pngi, bd->bdXResolution, bd->bdYResolution, PNG_RESOLUTION_METER);
 	    break;
 
 	case BMunINCH:
-	    pngi->phys_unit_type= PNG_RESOLUTION_METER;
-	    pngi->x_pixels_per_unit= (int)( 39.37* bd->bdXResolution );
-	    pngi->y_pixels_per_unit= (int)( 39.37* bd->bdYResolution );
-	    pngi->valid |= PNG_INFO_pHYs;
+	    png_set_pHYs(png, pngi, (int)( 39.37* bd->bdXResolution ), (int)( 39.37* bd->bdYResolution), PNG_RESOLUTION_METER);
 	    break;
 
 	case BMunPOINT:
-	    pngi->phys_unit_type= PNG_RESOLUTION_METER;
-	    pngi->x_pixels_per_unit= POINTS_PER_M* bd->bdXResolution;
-	    pngi->y_pixels_per_unit= POINTS_PER_M* bd->bdYResolution;
-	    pngi->valid |= PNG_INFO_pHYs;
+	    png_set_pHYs(png, pngi, (int)( POINTS_PER_M* bd->bdXResolution ), (int)( POINTS_PER_M* bd->bdYResolution), PNG_RESOLUTION_METER);
 	    break;
 
 	case BMunPIXEL:
-	    pngi->phys_unit_type= PNG_RESOLUTION_UNKNOWN;
-	    pngi->x_pixels_per_unit= 1;
-	    pngi->y_pixels_per_unit= 1;
+	    png_set_pHYs(png, pngi, 1, 1, PNG_RESOLUTION_UNKNOWN);
 	    break;
 
 	default:
 	    LDEB(bd->bdUnit);
-	    pngi->phys_unit_type= PNG_RESOLUTION_UNKNOWN;
+	    png_set_pHYs(png, pngi, 0, 0, PNG_RESOLUTION_UNKNOWN);
 	    break;
 	}
 
+    {
+    png_color_8 sig_bit;
     switch( bd->bdColorEncoding )
 	{
 	int	i;
 
 	case BMcoBLACKWHITE:
 	case BMcoWHITEBLACK:
-	    pngi->bit_depth= bd->bdBitsPerPixel;
+	    bit_depth= bd->bdBitsPerPixel;
 	    if  ( bd->bdHasAlpha )
-		{ pngi->color_type= PNG_COLOR_TYPE_GRAY_ALPHA;	}
-	    else{ pngi->color_type= PNG_COLOR_TYPE_GRAY;	}
-	    pngi->sig_bit.gray= bd->bdBitsPerSample;
+		{ color_type= PNG_COLOR_TYPE_GRAY_ALPHA;	}
+	    else{ color_type= PNG_COLOR_TYPE_GRAY;	}
+	    sig_bit.gray= bd->bdBitsPerSample;
 	    break;
 
 	case BMcoRGB:
-	    pngi->bit_depth= bd->bdBitsPerSample;
+	    bit_depth= bd->bdBitsPerSample;
 	    if  ( bd->bdHasAlpha )
-		{ pngi->color_type= PNG_COLOR_TYPE_RGB_ALPHA;	}
-	    else{ pngi->color_type= PNG_COLOR_TYPE_RGB;		}
-	    pngi->sig_bit.red= bd->bdBitsPerSample;
-	    pngi->sig_bit.green= bd->bdBitsPerSample;
-	    pngi->sig_bit.blue= bd->bdBitsPerSample;
+		{ color_type= PNG_COLOR_TYPE_RGB_ALPHA;	}
+	    else{ color_type= PNG_COLOR_TYPE_RGB;		}
+	    sig_bit.red= bd->bdBitsPerSample;
+	    sig_bit.green= bd->bdBitsPerSample;
+	    sig_bit.blue= bd->bdBitsPerSample;
 	    break;
 
 	case BMcoRGB8PALETTE:
-	    pngi->bit_depth= bd->bdBitsPerPixel;
-	    pngi->color_type= PNG_COLOR_TYPE_PALETTE;
+	    {
+	    png_colorp palette;
+	    int num_palette;
 
-	    pngi->valid |= PNG_INFO_PLTE;
-	    pngi->palette= (png_color *)malloc( 256* sizeof( png_color ) );
-	    if  ( ! pngi->palette )
-		{ XDEB(pngi->palette); return -1;	}
-	    pngi->num_palette= bd->bdColorCount;
-	    pngi->sig_bit.red= bd->bdBitsPerSample;
-	    pngi->sig_bit.green= bd->bdBitsPerSample;
-	    pngi->sig_bit.blue= bd->bdBitsPerSample;
-	    for ( i= 0; i < pngi->num_palette; i++ )
+	    bit_depth= bd->bdBitsPerPixel;
+	    color_type= PNG_COLOR_TYPE_PALETTE;
+
+	    palette= (png_color *)malloc( 256* sizeof( png_color ) );
+	    if  ( ! palette )
+		{ XDEB(palette); return -1;	}
+	    num_palette= bd->bdColorCount;
+	    sig_bit.red= bd->bdBitsPerSample;
+	    sig_bit.green= bd->bdBitsPerSample;
+	    sig_bit.blue= bd->bdBitsPerSample;
+	    for ( i= 0; i < num_palette; i++ )
 		{
-		pngi->palette[i].red= bd->bdRGB8Palette[i].rgb8Red;
-		pngi->palette[i].green= bd->bdRGB8Palette[i].rgb8Green;
-		pngi->palette[i].blue= bd->bdRGB8Palette[i].rgb8Blue;
+		palette[i].red= bd->bdRGB8Palette[i].rgb8Red;
+		palette[i].green= bd->bdRGB8Palette[i].rgb8Green;
+		palette[i].blue= bd->bdRGB8Palette[i].rgb8Blue;
 		}
+	    png_set_PLTE( png, pngi, palette, num_palette );
+	    }
 	    break;
 
 	default:
 	    LDEB(bd->bdColorEncoding);
 	    return -1;
 	}
+    png_set_sBIT( png, pngi, &sig_bit);
+    }
+    png_set_IHDR( png, pngi, bd->bdPixelsWide, bd->bdPixelsHigh, bit_depth,
+        color_type, 0, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
 
-    pngi->interlace_type= 0;
 
     return 0;
     }
@@ -395,7 +399,7 @@ static void bmPngWriteContents(	png_stru
 	    }
 	}
 
-    if  ( pngi->color_type == PNG_COLOR_TYPE_RGB	&&
+    if  ( png_get_color_type( png, pngi ) == PNG_COLOR_TYPE_RGB	&&
 	  bd->bdBitsPerSample == 16			)
 	{
 	const unsigned short	one= 1;
@@ -431,7 +435,7 @@ static void bmPngWriteContents(	png_stru
 	    from= scratch;
 	    }
 
-	if  ( pngi->color_type == PNG_COLOR_TYPE_RGB	&&
+	if  ( png_get_color_type( png, pngi ) == PNG_COLOR_TYPE_RGB	&&
 	      bd->bdBitsPerSample == 16			&&
 	      scratch					)
 	    {
@@ -453,9 +457,15 @@ static void bmPngWriteContents(	png_stru
 
     png_write_end( png, pngi );
 
-    if  ( bd->bdColorEncoding == BMcoRGB8PALETTE	&&
-	  pngi->palette					)
-	{ free( pngi->palette );	}
+    if  ( bd->bdColorEncoding == BMcoRGB8PALETTE )
+	{
+	  png_colorp palette;
+	  int num_palette;
+
+	  png_get_PLTE( png, pngi, &palette, &num_palette );
+	  if (palette) 
+	    { free( palette );	}
+        }
 
     if  ( scratch )
 	{ free( scratch );	}
